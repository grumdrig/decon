#abcdefghijklmnopqrstuvwxyz
#ABCDEFGHIJKLMNOPQRSTUVWXYZ
#19191919191919191919191919
#[one][two][three]OK
#>ĂĂĂĂĂĂĂĂĂĂĂĂĂĂĂĂĂĂĂĂĂĂĂĂĂĂĂĂĂĂĂĂĂĂĂĂĂĂĂĂĂĂĂĂĂĂĂĂĂĂĂĂĂĂĂĂĂĂĂĂĂĂĂĂĂĂĂĂĂĂĂĂ<

Main: {
  at 0 Test1 test1
  at 0 Test2 test2
  at 0 Test3 test3
  at 0 Test4 test4
  at 0 Test5 test5
  at 0 Test6 test6
  at 0 Test7 test7
  at 0 Test8 test8
  at 0 Test9 test9
  at 0 Test10 test10
  at 0 Test11 test11
  at 0 Test12 test12
  at 0 Test13 test13
  at 0 Test14 test14
  at 0 Test15 test15
  at 0 Test16 test16
  at 0 Test17 test17
  at 0 Test18 test18
  at 0 Test19 test19
  at 0 Test20 test20
  at 0 Test21 test21
  at 0 Test22 test22
  at 0 Test23 test23
  at 0 Test24 test24
  at 0 Test25 test25
  at 0 Test26 test26
  at 0 Test27 test27
  at 0 Test28 test28
  at 0 Test29 test29
}


Test1: {
  char[5] "#abcd" f1
  char[5]
  char[10] f2
  {
    bool bool
    null null
  }[2] nada
}


Test2: {
  at(1) littleendian int8 'a' a
  at(1) bigendian    int8 'a' a_
  at(1) littleendian int16 'ba' ba
  at(1) bigendian    int16 'ab' ab
  at(1) littleendian int32 'dcba' dcba
  at(1) bigendian    int32 'abcd' abcd
}


Test3: {
  char[before 'L']
  "LMNOP"
  char Q
  TString "RST" totee
}.check(Q = "Q")
terminator = char 'T'
TString: char[through terminator]


Test4: {
  byte[before '1']
  Little little
  Big big
}
Word: signed size 16 byte
Big: bigendian { Word word }
Little: littleendian { Word word }

 
Test5: {
  char[through "["]
  char[before ']']  one
  char[2] apple
  byte[through 'o'] two
  char closebracket
  "[three]"
  "OK" ok
}


Test6: {
  at(0) String5 reprise
  byte thing1
  byte (thing1 + 1) thing2
  {byte (thing1 + 2 + N) b}[2 index N] things
}
String5: char[5]


Test7: {
  byte '#'
  uint8 'a'
  uint16 'bc'
  uint32 'defg'
  uint64 'hijklmno'
  sbyte 'p'
  int8 'q'
  int16 'rs'
  char[until '#']
  int32 'ABCD'
  int64 'EFGHIJKL'
  char mmmmhmmm
}


Test8: {
  char pound
  char a
  char b
}.select(a).equals "a"


czech: null.select(true)  # TODO: make official?
Test9: union {
  {check (1 = 3) null; char oughtnt}
  {czech (2 = 3); char shouldnt}
  {equals "N" char wouldnt}
  {czech ("t" = "t"); char[2] should}
  "#abc"
}.equals {"should":"#a"}

# Recursive def'n
Test10: union {
  {"#"; Test10 pound}
  {"a" a}
}
 

Test11: {
  char key1
  char value1
  char key2
  char value2
  null.select {key1:value1} map1
  null.select {key1:value1, key2:value2} map2
}.select(map2).equals {"b":"c","#":"a"}


Test12: char.check(this = "#")


Test13: byte[3].equals ['#', 'a', 'b']


Test14: { 
  char[through 'z']
  char "\n" newline
}


Test15: {
  char[through '>']
  char ahornc
  byte ahornb
  int16 i16
  uint16 u16
  int32 i32
  uint32 u32
  int64 i64
  uint64 u64
}

<script>
function double(x) {
  return x + x;
}
function triplethis() {
  return this + this + this;
}
</script>

Test16: {
  char
  char[3].select(double(this)) "abcabc" abcabc
  char[2].select(triplethis()) "dedede" de3
}


Test17: {
  OtherFile.deconstruct("ZYXWandetc") another
  OtherFile.load("examples/test.con") other
}
OtherFile: { char[3][3] threeStrings; byte[] }

<script>
function thebits() {
  var r = [];
  for (var i = 7; i >= 0; --i)
    r.push(this >> i & 1);
  return r;
}
function thenibbles() {
  return [this >> 4, this & 0xf];
}
</script>

Test18: {
  byte.at(0).select(thebits()) bpound;
  bit[8].at(0) (bpound) pound;
  byte.at(1).select(thenibbles()) na;
  nibble[2].at(1) (na) a;
}
bit: size 1 byte;
nibble: size 4 byte;

Test19: {
  bit[8][8][2] somebits;
  null.select(position) (0x10) pos;
}

Test20: {
  char[10].cast(char[until 'c']) "#ab"
  char[10].cast(char[until 'm']) "jkl"
  null.select("hello\000\000\000") hello1
  null.select("hello\000\000\000").cast(cstring) "hello" hello
}


Test21: {}
Test22: {}
Test23: {}
Test24: {}
Test25: {}
Test26: {}
Test27: {}
Test28: {}
Test29: {}

